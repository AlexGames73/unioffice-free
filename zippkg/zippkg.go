//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg

import (
	_b "archive/zip"
	_ee "bytes"
	_bd "encoding/xml"
	_de "fmt"
	_dg "github.com/AlexGames73/unioffice-free"
	_bb "github.com/AlexGames73/unioffice-free/algo"
	_ef "github.com/AlexGames73/unioffice-free/common/tempstorage"
	_bg "github.com/AlexGames73/unioffice-free/schema/soo/pkg/relationships"
	_d "io"
	_gd "path"
	_e "sort"
	_c "strings"
	_g "time"
)

func MarshalXMLByTypeIndex(z *_b.Writer, dt _dg.DocType, typ string, idx int, v interface{}) error {
	_gdc := _dg.AbsoluteFilename(dt, typ, idx)
	return MarshalXML(z, _gdc, v)
}

func MarshalXMLByType(z *_b.Writer, dt _dg.DocType, typ string, v interface{}) error {
	_baf := _dg.AbsoluteFilename(dt, typ, 0)
	return MarshalXML(z, _baf, v)
}

func (_ac *DecodeMap) RecordIndex(path string, idx int) { _ac._eff[path] = idx }

var _eeab = []byte{'\r', '\n'}

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_db *DecodeMap) AddTarget(filePath string, ifc interface{}, sourceFileType string, idx uint32) bool {
	if _db._gfc == nil {
		_db._gfc = make(map[string]Target)
		_db._ca = make(map[*_bg.Relationships]string)
		_db._a = make(map[string]struct{})
		_db._eff = make(map[string]int)
	}
	_cb := _gd.Clean(filePath)
	if _, _gaeb := _db._a[_cb]; _gaeb {
		return false
	}
	_db._a[_cb] = struct{}{}
	_db._gfc[_cb] = Target{Path: filePath, Typ: sourceFileType, Ifc: ifc, Index: idx}
	return true
}

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp(f *_b.File, path string) (string, error) {
	_gffc, _ce := _ef.TempFile(path, "\u007a\u007a")
	if _ce != nil {
		return "", _ce
	}
	defer _gffc.Close()
	_fab, _ce := f.Open()
	if _ce != nil {
		return "", _ce
	}
	defer _fab.Close()
	_, _ce = _d.Copy(_gffc, _fab)
	if _ce != nil {
		return "", _ce
	}
	return _gffc.Name(), nil
}

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{ W _d.Writer }

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk(z *_b.Writer, zipPath, storagePath string) error {
	_ffd, _ba := z.Create(zipPath)
	if _ba != nil {
		return _de.Errorf("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073", zipPath, _ba)
	}
	_bcc, _ba := _ef.Open(storagePath)
	if _ba != nil {
		return _de.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", storagePath, _ba)
	}
	defer _bcc.Close()
	_, _ba = _d.Copy(_ffd, _bcc)
	return _ba
}

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct {
	_gfc map[string]Target
	_ca  map[*_bg.Relationships]string
	_eb  []Target
	_be  OnNewRelationshipFunc
	_a   map[string]struct{}
	_eff map[string]int
}

const XMLHeader = "\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e" + "\u000a"

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func(_gf *DecodeMap, _ga, _gg string, _fd []*_b.File, _gae *_bg.Relationship, _cc Target) error

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes(z *_b.Writer, zipPath string, data []byte) error {
	_def, _ad := z.Create(zipPath)
	if _ad != nil {
		return _de.Errorf("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073", zipPath, _ad)
	}
	_, _ad = _d.Copy(_def, _ee.NewReader(data))
	return _ad
}

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode(f *_b.File, dest interface{}) error {
	_gbc, _fde := f.Open()
	if _fde != nil {
		return _de.Errorf("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", f.Name, _fde)
	}
	defer _gbc.Close()
	_ddg := _bd.NewDecoder(_gbc)
	if _fb := _ddg.Decode(dest); _fb != nil {
		return _de.Errorf("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073", f.Name, _fb)
	}
	if _gda, _aa := dest.(*_bg.Relationships); _aa {
		for _aae, _fc := range _gda.Relationship {
			switch _fc.TypeAttr {
			case _dg.OfficeDocumentTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.OfficeDocumentType
			case _dg.StylesTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.StylesType
			case _dg.ThemeTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.ThemeType
			case _dg.ControlTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.ControlType
			case _dg.SettingsTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.SettingsType
			case _dg.ImageTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.ImageType
			case _dg.CommentsTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.CommentsType
			case _dg.ThumbnailTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.ThumbnailType
			case _dg.DrawingTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.DrawingType
			case _dg.ChartTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.ChartType
			case _dg.ExtendedPropertiesTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.ExtendedPropertiesType
			case _dg.CustomXMLTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.CustomXMLType
			case _dg.WorksheetTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.WorksheetType
			case _dg.SharedStringsTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.SharedStringsType
			case _dg.TableTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.TableType
			case _dg.HeaderTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.HeaderType
			case _dg.FooterTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.FooterType
			case _dg.NumberingTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.NumberingType
			case _dg.FontTableTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.FontTableType
			case _dg.WebSettingsTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.WebSettingsType
			case _dg.FootNotesTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.FootNotesType
			case _dg.EndNotesTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.EndNotesType
			case _dg.SlideTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.SlideType
			case _dg.VMLDrawingTypeStrict:
				_gda.Relationship[_aae].TypeAttr = _dg.VMLDrawingType
			}
		}
		_e.Slice(_gda.Relationship, func(_eea, _gbg int) bool {
			_acb := _gda.Relationship[_eea]
			_aec := _gda.Relationship[_gbg]
			return _bb.NaturalLess(_acb.IdAttr, _aec.IdAttr)
		})
	}
	return nil
}

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ff *DecodeMap) SetOnNewRelationshipFunc(fn OnNewRelationshipFunc) { _ff._be = fn }

type Target struct {
	Path  string
	Typ   string
	Ifc   interface{}
	Index uint32
}

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor(path string) string {
	_cce := _c.Split(path, "\u002f")
	_aca := _c.Join(_cce[0:len(_cce)-1], "\u002f")
	_ae := _cce[len(_cce)-1]
	_aca += "\u002f_\u0072\u0065\u006c\u0073\u002f"
	_ae += "\u002e\u0072\u0065l\u0073"
	return _aca + _ae
}

var _ddc = []byte{'/', '>'}

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML(z *_b.Writer, filename string, v interface{}) error {
	_ebb := &_b.FileHeader{}
	_ebb.Method = _b.Deflate
	_ebb.Name = filename
	_ebb.SetModTime(_g.Now())
	_eac, _faa := z.CreateHeader(_ebb)
	if _faa != nil {
		return _de.Errorf("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073", filename, _faa)
	}
	_, _faa = _eac.Write([]byte(XMLHeader))
	if _faa != nil {
		return _de.Errorf("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073", filename, _faa)
	}
	if _faa = _bd.NewEncoder(SelfClosingWriter{_eac}).Encode(v); _faa != nil {
		return _de.Errorf("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073", filename, _faa)
	}
	_, _faa = _eac.Write(_eeab)
	return _faa
}

// Decode loops decoding targets registered with AddTarget and calling th
func (_gc *DecodeMap) Decode(files []*_b.File) error {
	_ab := 1
	for _ab > 0 {
		for len(_gc._eb) > 0 {
			_gff := _gc._eb[0]
			_gc._eb = _gc._eb[1:]
			_dd := _gff.Ifc.(*_bg.Relationships)
			for _, _dgf := range _dd.Relationship {
				_cf, _ := _gc._ca[_dd]
				_gc._be(_gc, _cf+_dgf.TargetAttr, _dgf.TypeAttr, files, _dgf, _gff)
			}
		}
		for _afc, _ag := range files {
			if _ag == nil {
				continue
			}
			if _bef, _fa := _gc._gfc[_ag.Name]; _fa {
				delete(_gc._gfc, _ag.Name)
				if _gb := Decode(_ag, _bef.Ifc); _gb != nil {
					return _gb
				}
				files[_afc] = nil
				if _ea, _ffc := _bef.Ifc.(*_bg.Relationships); _ffc {
					_gc._eb = append(_gc._eb, _bef)
					_ec, _ := _gd.Split(_gd.Clean(_ag.Name + "\u002f\u002e\u002e\u002f"))
					_gc._ca[_ea] = _ec
					_ab++
				}
			}
		}
		_ab--
	}
	return nil
}

func (_gcg SelfClosingWriter) Write(b []byte) (int, error) {
	_gce := 0
	_cfa := 0
	for _cfe := 0; _cfe < len(b)-2; _cfe++ {
		if b[_cfe] == '>' && b[_cfe+1] == '<' && b[_cfe+2] == '/' {
			_ccc := []byte{}
			_gcf := _cfe
			for _dca := _cfe; _dca >= 0; _dca-- {
				if b[_dca] == ' ' {
					_gcf = _dca
				} else if b[_dca] == '<' {
					_ccc = b[_dca+1 : _gcf]
					break
				}
			}
			_defa := []byte{}
			for _da := _cfe + 3; _da < len(b); _da++ {
				if b[_da] == '>' {
					_defa = b[_cfe+3 : _da]
					break
				}
			}
			if !_ee.Equal(_ccc, _defa) {
				continue
			}
			_ebg, _gfca := _gcg.W.Write(b[_gce:_cfe])
			if _gfca != nil {
				return _cfa + _ebg, _gfca
			}
			_cfa += _ebg
			_, _gfca = _gcg.W.Write(_ddc)
			if _gfca != nil {
				return _cfa, _gfca
			}
			_cfa += 3
			for _befb := _cfe + 2; _befb < len(b) && b[_befb] != '>'; _befb++ {
				_cfa++
				_gce = _befb + 2
				_cfe = _gce
			}
		}
	}
	_fdd, _aee := _gcg.W.Write(b[_gce:])
	return _fdd + _cfa, _aee
}

func (_bdb *DecodeMap) IndexFor(path string) int { return _bdb._eff[path] }
